// queryBuilder.ts
import { type TriplitQueryBuilder } from "./handler/types";
// Import BOTH 'and' and 'or' from the triplit client
import { and, or } from "@triplit/client";

/**
 * Type representing a condition structure generated by the builder methods.
 */
type BuilderCondition =
  | { field: string; operator: string; value: any }
  | { connector: "AND" | "OR"; left: any; right: any };

/**
 * Type representing the structure Triplit's Where() method accepts.
 * This can be a single clause tuple, an array of clauses (implicit AND),
 * or the result of calling the imported `and()` or `or()` functions.
 */
type TriplitWhereArgument =
  | [string, string, any]
  | any[] // Array of clauses or nested and/or structures
  | ReturnType<typeof and> // Structure returned by and()
  | ReturnType<typeof or>; // Structure returned by or()


/**
 * Creates a composable query structure for Triplit's `Where` method
 * using a builder pattern.
 *
 * @param builderFn A function receiving the query builder object (q) and returning a condition structure.
 * @returns A structure (typically an array or nested `and`/`or` calls) suitable for `client.query(...).Where(...)`.
 */
export function queryBuilder(
  builderFn: (builder: TriplitQueryBuilder) => BuilderCondition | BuilderCondition[]
): TriplitWhereArgument {
  // Create a query builder object with methods matching common query operations
  const builder: TriplitQueryBuilder = {
    // Basic comparison operators
    eq: (field: string, value: any) => ({ field, operator: "=", value }),
    neq: (field: string, value: any) => ({ field, operator: "!=", value }),
    gt: (field: string, value: any) => ({ field, operator: ">", value }),
    gte: (field: string, value: any) => ({ field, operator: ">=", value }),
    lt: (field: string, value: any) => ({ field, operator: "<", value }),
    lte: (field: string, value: any) => ({ field, operator: "<=", value }),

    // Set/Array operators
    in: (field: string, value: any[]) => ({ field, operator: "in", value }),
    // Map 'not_in' from builder to 'not in' operator string used by Triplit/transform
    not_in: (field: string, value: any[]) => ({ field, operator: "not in", value }),

    // Contains operators (assuming Triplit supports them)
    contains: (field: string, value: any) => ({ field, operator: "contains", value }),
    // Map 'notContains' from builder to 'not contains' operator string
    notContains: (field: string, value: any) => ({ field, operator: "not contains", value }),

    // Logical connectors
    and: (left: any, right: any) => ({ connector: "AND", left, right }),
    or: (left: any, right: any) => ({ connector: "OR", left, right }),
  };

  // Call the user's builder function with our builder object
  const queryStructure = builderFn(builder);

  // Convert the potentially complex structure from the builder
  // into the format Triplit's Where() method expects.
  return convertBuilderStructure(queryStructure);
}

/**
 * Recursively converts the structure generated by the query builder
 * into a format compatible with Triplit's `Where` method arguments,
 * utilizing the imported `and` and `or` functions.
 *
 * @param structure The structure generated by the builder function.
 * @returns A structure suitable for `client.query(...).Where(...)`.
 */
function convertBuilderStructure(structure: any): TriplitWhereArgument {
  // Handle null or undefined inputs
  if (structure === null || structure === undefined) {
    // Triplit's Where likely ignores null/undefined, but returning empty array might be safer
    // or throwing an error if this state is unexpected. Let's return [] for now.
    return [];
  }

  // If it's already a string (e.g., user manually passed something), return as is? Risky.
  // Best practice is the builderFn should return structures from the builder.
  // Let's assume input is object or array from the builder.

  // If it's an array (potentially from user returning multiple conditions)
  if (Array.isArray(structure)) {
    // Convert each item in the array. This results in an array of clauses/structures,
    // which Triplit treats as an implicit AND.
    return structure.map(item => convertBuilderStructure(item));
  }

  // If it's a compound condition { connector, left, right }
  if (structure.connector) {
    const { connector, left, right } = structure;

    // Recursively convert the left and right parts
    const convertedLeft = convertBuilderStructure(left);
    const convertedRight = convertBuilderStructure(right);

    // Use the imported 'and' or 'or' functions from Triplit client
    if (connector === "AND") {
      // Ensure we pass an array to and/or
      return and([convertedLeft, convertedRight].flat()); // flat() handles nested arrays if needed
    } else if (connector === "OR") {
      return or([convertedLeft, convertedRight].flat());
    }
    // Fallthrough for unexpected connector? Or throw error? Let's throw.
    throw new Error(`Unsupported connector type: ${connector}`);

  }

  // If it's a simple condition { field, operator, value }
  if (structure.field && 'operator' in structure && 'value' in structure) {
    const { field, operator, value } = structure;
    // Convert to the [field, operator, value] tuple format
    return [field, operator, value];
  }

  // If the structure is none of the above, it's unexpected.
  console.warn("[queryBuilder] Unexpected structure encountered:", structure);
  // Returning the structure might cause errors in Triplit's Where.
  // Throwing an error might be safer depending on expected usage.
  throw new Error(`Invalid structure passed to or generated by queryBuilder: ${JSON.stringify(structure)}`);
  // Or return [] as a less disruptive fallback:
  // return [];
}
